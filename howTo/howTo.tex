\documentclass[a4paper]{article}
\usepackage[backend=bibtex,style=alphabetic]{biblatex}
\addbibresource{howto.bib}

\usepackage{a4wide}

\usepackage{hyperref} 
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{url}
\usepackage{xspace}
\usepackage[show]{ed}

\usepackage{listings}
\definecolor{WhiteSmoke}{HTML}{F5F5F5}
\definecolor{BlueViolet}{HTML}{8A2BE2}
\definecolor{Sienna}{HTML}{A0522D}
\lstset{
	keywordstyle=\color{BlueViolet}\bfseries, 
	basicstyle=\footnotesize\ttfamily, 
	commentstyle=\itshape\color{Sienna},
	showstringspaces=false, 
	backgroundcolor=\color{WhiteSmoke},
	breaklines=true
}

\lstdefinelanguage{RNC}%
  {morekeywords={default,namespace,=,start,attribute,include,element,notallowed},
   alsoother=$,%
   alsoletter=:,%
   showstringspaces=false,
   sensitive=true}

\lstdefinelanguage{mock}[]{XML}%
  {morekeywords={mock:document,mock:section,mock:subsection,mock:paragraph,mock:title,mock:p},
   sensitive=true}


\lstdefinelanguage{XSL}%
  {morekeywords={xmlns:mock,mock:document,mock:section,mock:subsection,mock:paragraph,mock:title,mock:p},
   showstringspaces=false,
   sensitive=true}%$

\def\latexml{{\LaTeX}ML\xspace}

\title{\textbf{How To Write A Minimal \latexml Binding}}
\author{\href{mailto:h.yuan@jacobs-university.de}{Hang Yuan}, 
	\href{mailto:jin.zhang@jacobs-university.de}{Jinbo Zhang},
        \href{mailto:m.kohlhase@jacobs-university.de}{Michael Kohlhase}\\
        Computer Science, Jacobs University Bremen}
\begin{document}
\maketitle

\section{Introduction}\label{sec:intro}

{\LaTeX}has been widely used as a document processor among scholars, especially when one
needs to use large quantities of mathematical representations. {\LaTeX} is also a good
choice for those who are meticulous about typographical quality of documents.

As a page formatting tool, the primary output format of the {\LaTeX} formatter is PDF;
which -- with fixed page formats and limited interaction features -- is only partially
suited for usage in the modern web. The DLMF (Digital Library of Mathematical Functions)
developed \latexml, a flexible, semantics-preserving {\LaTeX} to XML converter to fix
this.

However, for every {\LaTeX} class and package used in a document \latexml needs a
\textbf{\latexml binding} -- a configuration file that specifies the XML counterpart of
the {\LaTeX} command sequences provided by the respective class or package. 

Even though the \latexml distribution provides bindings for the most commonly used classes
and packages, the availability of bindings is still the most severe bottleneck for
\latexml. The \latexml documentation~\cite{LaTeXML:manual} is mostly written for developers and
quite impenetrable for beginners.

To encourage binding development this how-to tutorial goes through the steps and pitfalls
of creating a \latexml class binding from scratch. This tutorial does not cover advanced
topics related to \latexml, for which we refer to the \latexml manual~\cite{LaTeXML:manual}.

We have developed a minimal document class \lstinline|mockDoc| as an example for this
how-to and will go through it step-by-step. All necessary files (and the development
version of this tutorial )are available from~\cite{mockDoc:git}, but are also included in
the appendix of this document for reference.

This how-to tutorial is structured as follows: Section~\ref{sec:using} briefly reviews
\latexml workflows and the files involved.\ednote{MK: continue, when the struture is
  fixed} Section~\ref{sec:concl} concludes the tutorial.


\section{Using LaTeXML}\label{sec:using}

In this tutorial we we assume a working installation of \latexml -- see~\cite{LaTeXML:get}
for instructions -- on a Unix-like system (Linux, Mac OS, etc.). 

 Given that, we use the
command
\begin{lstlisting}[language=bash]
latexmlc mockDoc.tex --format=XML --destination=mockDoc.xml --log=mockDoc.xml.log
latexmlpost --stylesheet=mockDoc.xsl -dest=mockDoc.html mockDoc.xml 
\end{lstlisting}
for converting \lstinline|mockDoc.tex| into \lstinline|mockDoc.xml| and \lstinline|mockDoc.xml| into
\lstinline|mockDoc.html| \ednote{Actually, we
  should also have a HTML step, so that this shows the stylesheet as well.}

The conversion from {\LaTeX} to XML is processed by \latexml. Basically \latexml maps the
{\LaTeX} markups to the XML markups, more specifically: macros, primitives and
constructors. The post-processing mechanism such as conversion to HTML and XHTML is done by 
passing the the documents through the post-processing filter modules.

\subsection{Things We Need}
\begin{description}
\item[source] Here we use \lstinline|mockDoc.tex| as a minimal example\ednote{MK: make a
    minimal one, use that here } see appendix \ref{app:ex}\ednote{make other references}
\item[({\LaTeX} class)] we provide a {\LaTeX} class \lstinline|doc.cls| for reference;
  sometimes it is useful to generate PDF for proofreading. Also, the normal situation in
  developing \latexml bindings is that the class/package pre-exists. This file won't be
  illustrated in this tutorial. 
\item[\latexml binding] the core issue of this tutorial. We use \lstinline|doc.cls.ltxml|
  -- Section~\ref{sec:lxtml} for a step-by-step explanation and appendix~\ref{app:ltxml}
  for the end result.
\item[RelaxNG schema] \latexml needs a RelaxNG schema to infer the output structure. We
  supply it in compact form (\lstinline|mockDoc.rnc|; see appendix~\ref{app:rnc}, which
  can be converted to the XML form \latexml needs (\lstinline|mockDoc.rng|) via
  \lstinline|trang.jar|.  The reason for writing \lstinline|mockDoc.rnc| instead of
  \lstinline|mockDoc.rng| is that, \lstinline|mockDoc.rnc| is much shorter and easier to
  maintain. 
\end{description}
After you have finished writing all the documents above, run the command mentioned before,
and then you should be able to see the converted XML file for \lstinline|mockDoc.tex|. In
the following chapters we will explain how to construct \lstinline|mockDoc.rnc| and
\lstinline|doc.cls.ltxml|\ednote{MK: I think we should rename doc.cls and doc.cls.ltxml to
  mockDoc.cls, ... }.

These workflows can be automated via a Unix \lstinline|makefile| (see
appendix~\ref{app:mk}), which re-generates everything when source files have changed. Then
only need to issue the command:
\begin{lstlisting}[language=bash]
make
\end{lstlisting}
\begin{oldpart}{put somewhere else}
  you should be able to see the generated \lstinline|mockDoc.xml| in your current
  directory. It should be something similar to your expected
  \lstinline|mockDoc\_sample.xml|.
\end{oldpart}

\section{The mockDoc Format}\label{sec:mockdoc}

\subsection{A minimal Document Format}
Actually our \lstinline|mockDoc|format is probably the smallest one in the world, it is
only intended for this tutorial. 

The {\LaTeX} class only provides one environment: \lstinline|document| and four macros:
\lstinline|\section|, \lstinline|\subsection|, \lstinline|\paragraph|, and
\lstinline|\newline|. A minimal example would be

\lstinputlisting[language={[LaTeX]TeX},caption=A Minimal {\LaTeX} Document,label=lst:minimal.tex]{mockDoc.tex}

We want to use this document class for generating XML documents, which use the five
elements \lstinline|document|, \lstinline|\section|, \lstinline|\subsection|,
\lstinline|\paragraph|, and \lstinline|\newline|. The XML document corresponding to the
{\LaTeX} document from Listing~\ref{lst:minimal.tex} is

\lstinputlisting[language={[LaTeX]TeX},caption=A Minimal {\LaTeX}
Document,label=minimal.xml]{mockDoc.xml} \ednote{MK: actually, we should make an idealized
  minimal XML example by remove all the XML-isms from the generated one and show it here.}

Note the typical format-specific differences between the presentation-oriented {\LaTeX}
and more content-oriented XML formats. The sectioning is conveyed by macros in {\LaTeX} --
only giving the start cues (here the numbered section headings) -- whereas the XML has
start and end tags\ednote{MK: are there more? Here would be the place to discuss them.}

\begin{oldpart}{MK: I do not understand this, what do you want to say here?}
  After you link \lstinline|mockDoc.tex| and \lstinline|doc.cls.ltxml| by changing your
  document class in your \lstinline|mockDoc.tex| into your \latexml binding name, in our
  case,``doc''. Put \lstinline|doc.cls.ltxml| and \lstinline|mockDoc.tex| in the same
  folder, \latexml will load your binding file automatically, when it tries to do the
  conversion.
\end{oldpart}


\subsection{The RelaxNG Schema}\label{sec:rnc}
Schema is a crucial document that decides how \lstinline|mockDoc.xml| is constructed. When
you are creating your own schema\footnote{Before you write your expected xml and schema,
  having a look at the links below can be beneficial:
  \url{http://relaxng.org/compact-tutorial-20030326.html};
  \url{http://www.w3schools.com/xml/}. }, one good approach to test this is to create your
expected \lstinline|mockDoc\_sample.xml| by hand, according to your
\lstinline|mockDoc.tex|, then compare \lstinline|mockDoc\_sample.xml| with the generated
\lstinline|mockDoc.xml|. You can easily accomplish this by using \textit{emacs nxml
  mode}\footnote{Here is a tutorial about Emacs nxml mode:
  \url{http://www.emacswiki.org/emacs/NxmlMode}}, in which you have the freedom to write
your expected \lstinline|mockDoc.xml|, while validating your \lstinline|mockDoc.xml| at
the same time. If validation fails, you can see the error message instantly, such that you
can debug your \lstinline|mockDoc.xml| or schema accordingly.\ednote{MK: convert all
  footnotes to citations!}

 In our \lstinline|mockDoc.rnc|:
\begin{lstlisting}
document = element document {p, section*}
section = element section {title,(p |subsection)*}
\end{lstlisting}
you can easily see that, under a \lstinline|document|, there can be either \lstinline|p| or \lstinline|section|, and under a \lstinline|section| there can be a \lstinline|title| followed by \lstinline|p| or a \lstinline|title| followed by a \lstinline|subsection|. This is because in the first section in \lstinline|mockDoc.tex|:
\begin{lstlisting}[language=TeX]
\section{A brief introduction about Shelley}
    Percy Bysshe Shelley (4 August 1792 -- 8 July 1822)...
\end{lstlisting}
there is no \lstinline|subsection| but texts directly. But in the other \lstinline|section|s, there are \lstinline|subsection|s. In your schema you need to consider all kinds of possible hierarchy of your elements.



\section{How to Create a \latexml Binding}
We now come to the central part of our tutorial: writing the \latexml binding
itself. Generally, a \latexml binding file is a Perl module -- and therefore underlies
Perl syntax, but special high-level commands simplify expressing the {\LaTeX}-to-XML
relation.

\subsection{Basic structure}
Since {\LaTeX} binding is a perl module, we need to initialize a binding file by adding
the followings in the beginning of \lstinline|doc.cls.ltxml|:
\begin{lstlisting}[language=Perl]
package LaTeXML::Package::Pool;
use strict;
use LaTeXML::Package;
use warnings;
\end{lstlisting}
At the end of \lstinline|doc.cls.ltxml|, don't forget to include
\begin{lstlisting}
1;
\end{lstlisting}
to make sure that perl works properly.

\subsection{Configure namespace}
 With:
\begin{lstlisting}
RegisterNamespace('mock'=>"https://kwarc.info/projects/mockDoc");
RelaxNGSchema("mockDoc.rng",'mock'=>"https://kwarc.info/projects/mockDoc");
\end{lstlisting}
 We declared the namespace associated the prefix \lstinline|mock| with the
 namespace.\ednote{MK: we have to explain the why more, not just what to do; that is
   generally the case.}

\subsection{Linebreaks}
The next task is to teach \latexml new commands used in \lstinline|mockDoc.tex|. Here is
an example:
\begin{lstlisting}
DefConstructor('\newline',"<mock:break/>");
\end{lstlisting}

This line defines how \latexml interprets \lstinline|\newline|, as you see,
\latexml will translate \lstinline|\newline| to \lstinline|<mock:break/>| in
\lstinline|mockDoc.xml|.

\subsection{Sectioning}
 When dealing with \lstinline|section|, things get a little tricky, with:
\begin{lstlisting}
DefConstructor('\section{}', "<mock:section><mock:title>#1</mock:title>");
\end{lstlisting}
we defined \lstinline|\section|. But, think about the closing tags. In \lstinline|mockDoc.tex|, we declared where the \lstinline|\section| starts and where the next \lstinline|\section| starts, nevertheless, we never wrote something like ``Now close this section". Here is why we need \lstinline|mockDoc.rnc|. This schema file tells \latexml what the structure of our document, and with:
\begin{lstlisting}
Tag('mock:section', autoClose=>1);
\end{lstlisting}
\latexml will close the section tags (i.e, adding \lstinline|</mock:section>|) whenever needed.

\subsection{The Document Environment}
You may think something like:
\begin{lstlisting}
DefEnvironment('{document}', "<mock:document>#body</mock:document>");
\end{lstlisting}
is enough for defining \lstinline|document| environment. You can try it, you will find that all spaces disappear. What we actually wrote in \lstinline|doc.cls.ltxml| is:
\begin{lstlisting}
DefEnvironment('{document}', "<mock:document>#body</mock:document>", beforeDigest => sub { AssignValue(inPreamble => 0); });
\end{lstlisting}
This code can prevent the error mentioned before, however, the mechanism of the \lstinline|beforeDigest| part is out of our discussion in this tutorial.

 For an environment, we don't need care about auto-closing, since an environment is always like
\begin{lstlisting}
\begin{*environment-name*}
content...
\end{*environment-name*}
\end{lstlisting}
where \lstinline|\end\{*environment-name*\}| will indicate where to close the tags.

\subsection{Auto-opening for Paragraphs}
Since we also want to write some texts directly under \lstinline|document|, without any \lstinline|section|. At this circumstance, we need auto-open for \lstinline|p|:
\begin{lstlisting}
Tag('mock:p', autoOpen=>1);
\end{lstlisting}
which will surround such texts.

\section{Postprocessing for Web Workflow}
After we obtain \lstinline|mockDoc.xml|, we can further utilize the power of \latexml to convert it into some other
useful formats such as HTML, HTML5 and XHTML. \latexml by default provides us with stylesheets for this conversion, however we are given freedom to customize this process by creating our own XSL and CSS stylesheets.

\subsection{XSL Stylesheet}
Similar to how we create RelaxNG schema, in \lstinline|mockDoc.xsl|
\begin{lstlisting}
<xsl:template match="/">
	<xsl:apply-templates/>
</xsl:template>	
\end{lstlisting}
we associate the template with the root of XML and then within the main structure, we tells \latexml to use other
template when needed.
\begin{lstlisting}
<xsl:template match="mock:section">
	<section>
	<span style="font-size:200%">
		<xsl:apply-templates select="mock:title"/>
	</span>
	<xsl:apply-templates select="mock:p"/>
	<xsl:apply-templates select="mock:subsection"/>
	</section>
</xsl:template>
\end{lstlisting}
In case of the section template, we let \latexml generate a section in HTML and then apply the templates for the macros that appear in \lstinline|mock:section| from our \lstinline|mockDoc.xml| file. Our \lstinline|mockDoc.xsl| should be consistent with our \lstinline|mockDoc.rnc| as they both define the structure of our documents, as you can see from the section definition in our \lstinline|mockDoc.rnc|, they both contain: title, p and subsection elements.
\begin{lstlisting}
section = element section {title,(p |subsection)*}
\end{lstlisting}

\section{Conclusion}\label{sec:concl}
\ednote{MK: say something here}
\begin{newpart}{MK: do not forget to discuss this somewhere}
  For a web workflow, where the ultimate goal is to generate HTML5, writing a document
  class from scratch may not be the most common workflow, since the majority of document
  classes in {\LaTeX} are derived in some way from \lstinline|article.cls| and therefore
  the \latexml bindings can inherit the from \lstinline|article.cls.ltmxl|, but in some
  cases we want to use \latexml to generate other XML-based format. There we need the
  techniques in this tutorial. Examples are generating OMDoc from s\TeX\ednote{MK: cite
    them from kwarc.bib, are there others?}
\end{newpart}

\printbibliography
\newpage

\begin{appendix}
\section{Appendix}
\subsection{The mockDoc Class}\label{app:cls}
\lstinputlisting[language={[LaTeX]TeX}]{doc.cls}

\subsection{The mockDoc Class Binding}\label{app:ltxml}
\lstinputlisting[language=Perl]{doc.cls.ltxml}

\subsection{mockDoc RelaxNG schema}\label{app:rnc}
\lstinputlisting[language=RNC]{mockDoc.rnc}

\subsection{Generated XML}\label{app:xml}
\lstinputlisting[language=mock]{mockDoc.xml}

\subsection{XSL stylesheet}\label{app:xsl}
\lstinputlisting[language=xsl]{mockDoc.xsl}

\subsection{Generated HTML}\label{app:html}
\lstinputlisting[language=html]{mockDoc.html}

\section{A Makefile for Automation}\label{app:mk}
\lstinputlisting[language=bash]{Makefile}
\end{appendix}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  maketitle noindent latexml textbf lstlisting latexmlc libxslt ednote nxml
%  LocalWords:  doc.cls mockDoc.rnc trang.jar trang.jar mockDoc.rng mockDoc.rng textit mk
%  LocalWords:  nxml Bysshe cls
%  LocalWords:  subsection printbibliography newpage lstinputlisting ltxml rnc oldpart
%  LocalWords:  lxtml mockdoc concl
