\documentclass[a4paper]{article}
\usepackage[backend=bibtex,style=alphabetic]{biblatex}
\addbibresource{howTo.bib}
\usepackage{a4wide}

\usepackage{hyperref} 
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage{xspace}
\usepackage[show]{ed}

\usepackage{listings}
\definecolor{WhiteSmoke}{HTML}{F5F5F5}
\definecolor{BlueViolet}{HTML}{8A2BE2}
\definecolor{Sienna}{HTML}{A0522D}
\lstset{
	keywordstyle=\color{BlueViolet}\bfseries, 
	basicstyle=\footnotesize\ttfamily, 
	commentstyle=\itshape\color{Sienna},
	showstringspaces=false, 
	backgroundcolor=\color{WhiteSmoke},
	breaklines=true
}

\lstdefinelanguage{RNC}%
  {morekeywords={default,namespace,=,start,attribute,include,element,notallowed},
   alsoother=$,%
   alsoletter=:,%
   showstringspaces=false,
   sensitive=true}

\lstdefinelanguage{mock}[]{XML}%
  {morekeywords={mock:document,mock:section,mock:subsection,mock:paragraph,mock:title,mock:p},
   sensitive=true}


\lstdefinelanguage{XSL}%
  {morekeywords={xmlns:mock,mock:document,mock:section,mock:subsection,mock:paragraph,mock:title,mock:p},
   showstringspaces=false,
   sensitive=true}%$

\def\latexml{{\LaTeX}ML\xspace}

\title{\textbf{How To Write A Minimal \latexml Binding}}
\author{\href{mailto:h.yuan@jacobs-university.de}{Hang Yuan}, 
	\href{mailto:jin.zhang@jacobs-university.de}{Jinbo Zhang},
        \href{mailto:m.kohlhase@jacobs-university.de}{Michael Kohlhase}\\
        Computer Science, Jacobs University Bremen}
\begin{document}
\maketitle

\section{Introduction}\label{sec:intro}

{\LaTeX}has been widely used as a document processor among scholars, especially when one
needs to use large quantities of mathematical representations. {\LaTeX} is also a good
choice for those who are meticulous about typographical quality of documents.

As a page formatting tool, the primary output format of the {\LaTeX} formatter is PDF;
which -- with fixed page formats and limited interaction features -- is only partially
suited for usage in the modern web. The DLMF (Digital Library of Mathematical Functions)
developed \latexml, a flexible, semantics-preserving {\LaTeX} to XML converter to fix
this.

However, for every {\LaTeX} class and package used in a document \latexml needs a
\textbf{\latexml binding} -- a configuration file that specifies the XML counterpart of
the {\LaTeX} command sequences provided by the respective class or package. 

Even though the \latexml distribution provides bindings for the most commonly used classes
and packages, the availability of bindings is still the most severe bottleneck for
\latexml. The \latexml documentation~\cite{LaTeXML:manual} is mostly written for developers and
quite impenetrable for beginners.

To encourage binding development this how-to tutorial goes through the steps and pitfalls
of creating a \latexml class binding from scratch. This tutorial does not cover advanced
topics related to \latexml, for which we refer to the \latexml manual~\cite{LaTeXML:manual}.

We have developed a minimal document class \lstinline|mockDoc| as an example for this
how-to and will go through it step-by-step. All necessary files (and the development
version of this tutorial )are available from~\cite{mockDoc:git}, but are also included in
the appendix of this document for reference.

This how-to tutorial is structured as follows: section~\ref{sec:using} briefly reviews
\latexml workflows and the files involved; section~\ref{sec:mockdoc} introduces a minimal \TeX and its 
schema; section~\ref{sec:bind} gives a basic view of how to write \latexml binding; section~\ref{sec:posp} talks about postprocessing for web workflow; section~\ref{sec:concl} concludes the tutorial.


\section{Using LaTeXML}\label{sec:using}

In this tutorial we we assume a working installation of \latexml -- see~\cite{LaTeXML:get}
for instructions -- on a Unix-like system (Linux, Mac OS, etc.). 

 Given that, we use the
command
\begin{lstlisting}[language=bash]
latexmlc mockDoc.tex --format=XML --destination=mockDoc.xml --log=mockDoc.xml.log 
latexmlpost --stylesheet=mockDoc.xsl --destination=mockDoc.html mockDoc.xml
\end{lstlisting}
for converting \lstinline|mockDoc.tex| into \lstinline|mockDoc.xml| and \lstinline|mockDoc.xml| into
\lstinline|mockDoc.html|


The conversion from {\LaTeX} to XML is processed by \latexml. Basically \latexml maps the
{\LaTeX} markups to the XML markups, more specifically: macros, primitives and
constructors. The post-processing mechanism such as conversion to HTML and XHTML is done by 
passing the the documents through the post-processing filter modules.

\subsection{Things We Need}
\begin{description}
\item[Source] Here we use \lstinline|mockDoc.tex| as a minimal example see section ~\ref{sec:mockTex} \item[{\LaTeX} class] we provide a {\LaTeX} class \lstinline|mockDoc.cls| for reference; sometimes it is useful to generate PDF for proofreading. The  normal situation in
  developing \latexml bindings is that the class/package pre-exists. This file won't be
  illustrated in this tutorial - see appendix ~\ref{app:cls} for source.
\item[\latexml binding] the core issue of this tutorial. We use \lstinline|mockDoc.cls.ltxml|
  -- see section~\ref{sec:bind} for a step-by-step explanation and appendix~\ref{app:ltxml}
  for the end result.
\item[RelaxNG schema] \latexml needs a RelaxNG schema to infer the output structure. We
  supply it in compact form \lstinline|mockDoc.rnc| - see appendix~\ref{app:rnc} for source and section ~\ref{sec:rnc} for explanation, which
  can be converted to the XML form \latexml needs \lstinline|mockDoc.rng| via
  \lstinline|trang.jar|.  The reason for writing \lstinline|mockDoc.rnc| instead of
  \lstinline|mockDoc.rng| is that, \lstinline|mockDoc.rnc| is much shorter and easier to
  maintain. 
\item[XSL stylesheet] to customize our output in the web workflow, we can provide \latexml with 
  \lstinline|mockDoc.xsl|, showing a general idea of how postprocessing works - see appendix~\ref{app:html}
  for the effects and section ~\ref{sec:posp} for a detailed description.
\end{description} 
After we have finished writing all the documents above, run the command mentioned before,
and then we should be able to see the converted XML file for \lstinline|mockDoc.tex|. In
the following chapters we will explain how to construct \lstinline|mockDoc.rnc| and
\lstinline|mockDoc.cls.ltxml|


These workflows can be automated via a Unix \lstinline|makefile| (see
appendix~\ref{app:mk}), which re-generates everything when source files have changed. Then
only need to issue the command:
\begin{lstlisting}[language=bash]
make
\end{lstlisting}

\section{The mockDoc Format}\label{sec:mockdoc}

\subsection{A minimal Document Format}\label{sec:mockTex}
Actually our \lstinline|mockDoc| format is probably the smallest one in the world, it is
only intended for this tutorial. 

The {\LaTeX} class only provides one environment: \lstinline|document| and four macros:
\lstinline|\section|, \lstinline|\subsection|, \lstinline|\paragraph|, and
\lstinline|\newline|. A minimal example would be

\lstinputlisting[language={[LaTeX]TeX},caption=A Minimal {\LaTeX} Document,label=lst:minimal.tex]{mockDoc.tex}

We want to use this document class for generating XML documents, which use the five
elements \lstinline|document|, \lstinline|\section|, \lstinline|\subsection|,
\lstinline|\paragraph|, and \lstinline|\newline|. The XML document corresponding to the
{\LaTeX} document from Listing~\ref{lst:minimal.tex} is

\lstinputlisting[language={XML},caption=The Generated XML Document,label=minimal.xml]{mockDoc.xml} 

Note the typical format-specific differences between the content-oriented {\LaTeX}
and more data-oriented XML formats. The sectioning is conveyed by macros in {\LaTeX} --
only giving the start cues (here the numbered section headings) -- whereas the XML has
start and end tags. In addition, {\LaTeX} markup is less strict then XML markup, meaning {\LaTeX} more
suitable for somewhat messy human readable documents, whilst in XML not everything is allowed.   \

\subsection{The RelaxNG Schema}\label{sec:rnc}
Schema is a crucial document that decides how \lstinline|mockDoc.xml| is constructed. When
one is creating his own schema, the ~\cite{RelaxNG:tutorial} and ~\cite{XML:tutorial} are two
good documentations to get started. One good approach to test this is to create our
expected \lstinline|mockDoc\_sample.xml| by hand, according to our
\lstinline|mockDoc.tex|, then compare \lstinline|mockDoc\_sample.xml| with the generated
\lstinline|mockDoc.xml|. We can easily accomplish this by using \textit{emacs nxml
  mode} ~\cite{Emacs:nxml}, in which we have the freedom to write
our expected \lstinline|mockDoc.xml|, while validating our \lstinline|mockDoc.xml| at
the same time. If validation fails, we can see the error message instantly, such that we
can debug our \lstinline|mockDoc.xml| or schema accordingly.

In our \lstinline|mockDoc.rnc|:
\lstinputlisting[linerange={4-5}]{mockDoc.rnc}
We can easily see that, under a \lstinline|document|, there can be either \lstinline|p| or \lstinline|section|, and under a \lstinline|section| there can be a \lstinline|title| followed by \lstinline|p| or a \lstinline|title| followed by a \lstinline|subsection|. This is due to the first section in \lstinline|mockDoc.tex|:
\lstinputlisting[linerange={3-4}]{mockDoc.tex}
has no \lstinline|subsection| but text, and in the other \lstinline|section|s, there are \lstinline|subsection|s. We need to consider all possible hierarchies of our elements in the schema.



\section{How to Create a \latexml Binding}\label{sec:bind}
We now come to the central part of our tutorial: writing the \latexml binding
itself. Generally, a \latexml binding file is a Perl module -- and therefore underlies
Perl syntax, but special high-level commands simplify expressing the {\LaTeX}-to-XML
relation.

\subsection{Basic structure}
Since {\LaTeX} binding is a perl module, we need to initialize a binding file by adding
the followings in the beginning of \lstinline|mockDoc.cls.ltxml|:
\lstinputlisting[linerange={1-4}]{mockDoc.cls.ltxml}
At the end of \lstinline|mockDoc.cls.ltxml|, don't forget to include
\lstinputlisting[linerange={25-25}]{mockDoc.cls.ltxml}
to make sure that perl works properly.

\subsection{Configure namespace}
 With:
 \lstinputlisting[linerange={7-8}]{mockDoc.cls.ltxml}
 We declared the namespace associated the prefix \lstinline|mock| with the
 namespace, and thus we can use the prefix when defining new macros to avoid 
 name conflicts. The second lines tells \latexml that the generated xml should fit in our
 schema.

\subsection{Linebreaks}
The next task is to teach \latexml new commands used in \lstinline|mockDoc.tex|. Here is
an example:
 \lstinputlisting[linerange={15-15}]{mockDoc.cls.ltxml}

This line defines how \latexml interprets \lstinline|\newline|, as we see,
\latexml will translate \lstinline|\newline| to \lstinline|<mock:break/>| in
\lstinline|mockDoc.xml|.

\subsection{Sectioning}
 When dealing with \lstinline|section|, things get a little tricky, with:
  \lstinputlisting[linerange={12-12}]{mockDoc.cls.ltxml}
we defined \lstinline|\section|. But, think about the closing tags. In \lstinline|mockDoc.tex|, we declared where the \lstinline|\section| starts and where the next \lstinline|\section| starts, nevertheless, we never wrote something like ``Now close this section". Here is why we need \lstinline|mockDoc.rnc|. This schema file tells \latexml what the structure of our document, and with:
 \lstinputlisting[linerange={19-19}]{mockDoc.cls.ltxml}
\latexml will close the section tags (i.e, adding \lstinline|</mock:section>|) whenever needed.

\subsection{The Document Environment}
We may think something like:
\begin{lstlisting}
DefEnvironment('{document}', "<mock:document>#body</mock:document>");
\end{lstlisting}
is enough for defining \lstinline|document| environment. We can try it, but we will find that all spaces disappear. What we actually wrote in \lstinline|mockDoc.cls.ltxml| is:
 \lstinputlisting[linerange={11-11}]{mockDoc.cls.ltxml}
This code can prevent the error mentioned before, however, the mechanism of the \lstinline|beforeDigest| part is out of our discussion in this tutorial.

 For an environment, we don't need care about auto-closing, since an environment is always like
\begin{lstlisting}
\begin{*environment-name*}
content...
\end{*environment-name*}
\end{lstlisting}
where \lstinline|\end\{*environment-name*\}| will indicate where to close the tags.

\subsection{Auto-opening for Paragraphs}
Since we also want to write some texts directly under \lstinline|document|, without any \lstinline|section|. At this circumstance, we need auto-open for \lstinline|p|:
 \lstinputlisting[linerange={22-22}]{mockDoc.cls.ltxml}
which will surround such texts.


We now have a complete set of tiles to generate our XML file. Simply by using makefile, we should be able to see the generated \lstinline|mockDoc.xml| in our current directory. It should be something similar to we expected
\lstinline|mockDoc\_sample.xml|.
  
\section{Postprocessing for Web Workflow}\label{sec:posp}
After we obtain \lstinline|mockDoc.xml|, we can further utilize the power of \latexml to convert it into some other
useful formats such as HTML, HTML5 and XHTML. \latexml by default provides us with stylesheets for this conversion, however we are given the freedom to customize this process by creating our own XSL and CSS stylesheets.

\subsection{XSL Stylesheet}
Similar to how we create RelaxNG schema, in \lstinline|mockDoc.xsl|
 \lstinputlisting[linerange={22-24}]{mockDoc.xsl}

In case of the section template, we let \latexml generate a section in HTML and then apply the templates for the macros that appear in \lstinline|mock:section| from our \lstinline|mockDoc.xml| file. Our \lstinline|mockDoc.xsl| should be consistent with our \lstinline|mockDoc.rnc| as they both define the structure of our documents, as we can see from the section definition in our \lstinline|mockDoc.rnc|, they both contain: title, p and subsection elements.
 \lstinputlisting[linerange={5-5}]{mockDoc.rnc}
Also, we want to allow each children of a class to be processed whenever a template matches, to deal with situations where we have a subsection, that conrtins more than one paragraph can exist, so we use
 \lstinputlisting[linerange={13-13}]{mockDoc.xsl}
to check template matches.

\section{Conclusion}\label{sec:concl}
The trick of using \latexml is to get familiar with all the necessary components that are required for different processings, for instance if we want to customize the conversion from XML to HTML, it would be nice to know about \latexml schema, XSLT and XHTML. \latexml allows a large degree of customizations which maximizes the connivence of format conversion, particularly the conversion from \lstinline|tex| to \lstinline|xml|, as our prefer to use  {\TeX} for production and XML for delivery. For a web workflow, where the ultimate goal is to generate HTML5, writing a document class from scratch may not be the most common workflow, since the majority of document classes in {\LaTeX} is derived in some way from \lstinline|article.cls| and therefore
  the \latexml bindings can inherit the from \lstinline|article.cls.ltmxl|, but in some
  cases we want to use \latexml to generate other XML-based format. There we need the
  techniques in this tutorial. Examples are generating OMDoc from s\TeX\ednote{MK: cite
    them from kwarc.bib, are there others?}


\newpage

\begin{appendix}
\section{Appendix}

\subsection{The mockDoc Class}\label{app:cls}
\lstinputlisting[language={[LaTeX]TeX}]{mockDoc.cls}

\subsection{The mockDoc Class Binding}\label{app:ltxml}
\lstinputlisting[language=Perl]{mockDoc.cls.ltxml}

\subsection{mockDoc RelaxNG schema}\label{app:rnc}
\lstinputlisting[language=RNC]{mockDoc.rnc}

\subsection{XSL stylesheet}\label{app:xsl}
\lstinputlisting[language=xsl]{mockDoc.xsl}

\subsection{Generated HTML}\label{app:html}
\lstinputlisting[language=html]{mockDoc.html}

\section{A Makefile for Automation}\label{app:mk}
\lstinputlisting[language=bash]{Makefile}

\printbibliography

\end{appendix}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  maketitle noindent latexml textbf lstlisting latexmlc libxslt ednote nxml
%  LocalWords:  mockDoc.cls mockDoc.rnc trang.jar trang.jar mockDoc.rng mockDoc.rng textit mk
%  LocalWords:  nxml Bysshe cls
%  LocalWords:  subsection printbibliography newpage lstinputlisting ltxml rnc oldpart
%  LocalWords:  lxtml mockdoc concl
